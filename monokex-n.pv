(* Proverif 2.02p1 *)
(* Monokex, "N" pattern, warmup *)

(*
    TODO: this list should be empty:
    o) events
    o) query + inj-event
    o) H6 created, check via enc,dec
    o) mac, kdf via key type
    o) if T1 = T1 then set event (!)

    choice VS. query,noninfer,weaksecret (cant be in one file)
    o) choice, compare terms, will be another file (!)
    o) choice+sync
    o) etc.
*)

(* Public channel *)
free c: channel.

(* Constants *)
const pid: bitstring.
const zero: bitstring.

(* XXX, key! *)
type key.
fun mac(bitstring, bitstring) : bitstring.

(* Diffie-Hellman *)
type exponent.
const g: bitstring.
fun exp(bitstring, exponent): bitstring.
equation forall x: exponent, y: exponent;
   exp(exp(g, x), y) = exp(exp(g, y), x).

(* Symmetric encryption *)
fun enc(bitstring, bitstring): bitstring.
reduc forall a: bitstring, b: bitstring;
   dec(enc(a, b), b) = a.

(* Split *)
fun first(bitstring): bitstring.
fun second(bitstring): bitstring.
reduc forall x: bitstring;
   unsplit(first(x), second(x)) = x.

(* XXX, later check keys *)
free msg: bitstring [private].
query attacker(msg).

(* Secrecy assumptions *)
not attacker(new R).
not attacker(new E).

let Initiator(RS: bitstring) =
   new E: exponent;
   new p1: bitstring;

   let IE = exp(g, E) in
   let H0 = pid in
   let H1 = mac(H0, RS) in
   let H2 = mac(H1, H1) in
   let H3 = mac(H2, IE) in
   let H4 = mac(H3, exp(RS, E)) in
   let Z1 = enc(H4, zero) in
   let H5 = first(Z1) in
   let K1 = second(Z1) in
   let S1 = enc(K1, p1) in
   let Z2 = mac(H5, S1) in
   let H6 = first(Z2) in
   let T1 = second(Z2) in
   out(c, (IE, S1, T1))
.

let Responder(R: exponent, RS: bitstring) =
   in(c, (IE: bitstring, S1: bitstring, T1: bitstring));
   let H0 = pid in
   let H1 = mac(H0, RS) in
   let H2 = mac(H1, H1) in
   let H3 = mac(H2, IE) in
   let H4 = mac(H3, exp(IE, R)) in
   let Z1 = enc(H4, zero) in
   let H5 = first(Z1) in
   let K1 = second(Z1) in
   let Z2 = mac(H5, S1) in
   let H6 = first(Z2) in
   let T1 = second(Z2) in
   out(c, enc(H6, msg))
.

process
   new R: exponent;

   let RS = exp(g, R) in
   out(c, RS);
   (!Initiator(RS)) | (!Responder(R, RS))
