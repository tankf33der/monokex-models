(* Proverif 2.02p1 *)
(* Monokex, "N" pattern, warmup *)
(* active attacker by default *)
(*
$ proverif -color monokex-n.pv | egrep "RES|ok"
ok, secrecy assumption verified: fact unreachable attacker(R[])
ok, secrecy assumption verified: fact unreachable attacker(E[!1 = v])
ok, secrecy assumption verified: fact unreachable attacker(msgA[!1 = v])
ok, secrecy assumption verified: fact unreachable attacker(msgB[!1 = v])
RESULT not attacker(msgA[!1 = v]) is true.
ok, secrecy assumption verified: fact unreachable attacker(R[])
ok, secrecy assumption verified: fact unreachable attacker(E[!1 = v])
ok, secrecy assumption verified: fact unreachable attacker(msgA[!1 = v])
ok, secrecy assumption verified: fact unreachable attacker(msgB[!1 = v])
RESULT not attacker(msgB[!1 = v]) is true.
*)
(*
    ================================
    TODO: this list should be empty:
    o) events
    o) query event + inj-event (attacks: impersonation, replay)
    o) H6 created, check via enc,dec
    o) mac, kdf via key type
    o) if T1 = zT1 then set event (!)
    o)    ^^^^^^^ find the way to do it
    o) weaksecret msg
    o) deniability equivalence (nl, p 41)

    choice VS. query,noninfer,weaksecret (cant be in one file)
    o) replay attack detection via choice (manual, pp. 58-59)
    o) choice, compare terms, will be another file (!)
    o) choice+sync
    o) etc.
*)

(* Public channel *)
free c: channel.

(* Constants *)
const pid: bitstring.
const zero: bitstring.

(* XXX, use keys with correct params order *)
type mackey.
fun mac(bitstring, bitstring) : bitstring.

(* Diffie-Hellman *)
type exponent.
const g: bitstring.
fun exp(bitstring, exponent): bitstring.
equation forall x: exponent, y: exponent;
   exp(exp(g, x), y) = exp(exp(g, y), x).

(* Symmetric encryption *)
(* XXX, use keys with correct params order *)
fun enc(bitstring, bitstring): bitstring.
reduc forall a: bitstring, b: bitstring;
   dec(enc(a, b), b) = a.

(* Split (concat builtin kernel) *)
fun first(bitstring): bitstring.
fun second(bitstring): bitstring.
reduc forall x: bitstring;
   unsplit(first(x), second(x)) = x.

(* Secrecy query *)
(* XXX, later check keys *)
query attacker(new msgA).
query attacker(new msgB).

(* Secrecy assumptions *)
not attacker(new R).
not attacker(new E).
not attacker(new msgA).
not attacker(new msgB).

let Initiator(RS: bitstring) =
   new E: exponent;
   new p1: bitstring;
   new msgA: bitstring;

   let IE = exp(g, E) in
   let H0 = pid in
   let H1 = mac(H0, RS) in
   let H2 = mac(H1, H1) in
   let H3 = mac(H2, IE) in
   let H4 = mac(H3, exp(RS, E)) in
   let Z1 = enc(H4, zero) in
   let H5 = first(Z1) in
   let K1 = second(Z1) in
   let S1 = enc(K1, p1) in
   let Z2 = mac(H5, S1) in
   let H6 = first(Z2) in
   let T1 = second(Z2) in
   out(c, (IE, S1, T1));
   out(c, enc(H6, msgA))
.

let Responder(R: exponent, RS: bitstring) =
   new msgB: bitstring;

   in(c, (IE: bitstring, S1: bitstring, zT1: bitstring));
   let H0 = pid in
   let H1 = mac(H0, RS) in
   let H2 = mac(H1, H1) in
   let H3 = mac(H2, IE) in
   let H4 = mac(H3, exp(IE, R)) in
   let Z1 = enc(H4, zero) in
   let H5 = first(Z1) in
   let K1 = second(Z1) in
   let Z2 = mac(H5, S1) in
   let H6 = first(Z2) in
   let T1 = second(Z2) in
   (* if T1 = zT1 ... *)
   out(c, enc(H6, msgB))
.

process
   new R: exponent;

   let RS = exp(g, R) in
   out(c, RS);
   (!Initiator(RS)) | (!Responder(R, RS))
